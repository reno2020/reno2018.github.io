
<html>
<body>

<h1>2018-10</h1>

<p>My first paragraph.</p>




---------------------------------------------------------------------------------------------------------------------

java基础扎实，熟悉jvm性能调优、线程处理、设计模式、熟悉java编码规范

精通Java基础、多线程、理解JVM底层原理、深刻理解常用设计模式

深入使用Java，掌握常用的Java类库及框架，如多线程、并发处理、I/O与网络通讯

JAVA基础扎实：熟练掌握数据结构、多线程编程，掌握常用的设计模式；熟悉JVM，包括内存模型、类加载机制以及性能优化；

熟悉常见的中间件、分布式解决方案及其原理：分布式缓存、SOA、消息中间件，负载均衡、连接池

熟悉tomcat、Nginx等应用服务器，同时对在高并发处理情况下的负载调优有相关经验者优先考虑

精通spring spring boot spring cloud的原理以及bean加载机制

精通redis、memcached、kafka、mongodb、storm等技术，可以对其进行搭建及调优

熟悉spring boot, spring cloud, mybatis等主流开源应用框架，精通对spring的原理，熟读spring相关组件源码;

熟悉Maven的使用，理解Maven的原理与使用技巧、熟练用Git进行代码版本控制

熟悉docker、kubernetes、swarm相关技术和语法，熟悉jenkins部署脚本（优先）

精通Java语言，熟悉linux系统，了解Shell等脚本语言，对于面向对象模型和设计模式有清晰的认识，了解常用设计模式

必须有高并发、分布式、消息队列等项目实战经验

具有多线程、分布式、高并发、高负载、高可用性、系统调优等相关经验者优先

JAVA基础扎实，理解IO、线程、集合等基础框架，对JVM原理有一定的了解

熟悉分布式系统原理和设计，熟悉Redis 、Activemq 、Zookeeper、Dubbo等开源项目，能合理进行技术选型，善于解决问题

了解主要（Tomcat/redis/nginx等）的配置和使用，熟悉Linux操作系统

掌握jdK，多线程，锁机制；了解分布式、多线程等高性能架构相关开发技术

熟悉系统之间交互通讯方式、数据格式、通讯安全

熟悉Tomcat中间件、熟悉Docker容器化部署、了解CentOS操作系统

熟悉web前端技术，熟悉js框架，熟悉MySQL数据库使用及sql语句的编写，熟悉Nginx、Tomcat、Memcacheq、redis等中间件产品的配置和开发

熟悉分布式锁的实现原理

对技术有一定的前瞻性、熟悉cicd、devops和微服务、docker、k8s

熟悉ElasticSearch、Spark、Redis、MySQL、Druid、Kylin等技术中的至少2项以上

熟悉Vue、Echarts、Highcharts、有数据可视化工具开发经验者优先

高并发、高性能的分布式系统的设计及应用、调优、对系统和数据的安全性设计有相关经验

熟悉Spring, Jersey, MyBatis等主流企业级开发框架，并对框架的实现原理、使用限制、应用场合等有深入了解

熟悉分布式运算，网络架构，服务器，中间件，DB，缓存，存储解决方案，消息、搜索、线上运维等

熟悉Tomcat 、Jetty 、Nginx等主流应用服务器的配置和部署

熟练使用Eclipse/Idea、SVN、Git、Jenkins/Hudson、JIRA 等开发工具

Java基础扎实，精通IO、多线程、集合等基础框架，熟悉分布式、缓存、消息等机制，熟悉Spring、MyBatis等框架

精通TCP/IP、HTTP等网络协议，有使用Java开发高访问量高并发网络应用的经验

掌握Web后端开发技术：协议、架构、存储、缓存、安全等，良好的JAVA语言基础，熟悉Spring framework，MyBatis等常用框架和类库





---------------------------------------------------------------------------------------------------------------------




----------------------------------------------------------------------------</br>

----------------------------------------------------------------------------</br>

----------------------------------------------------------------------------</br>

----------------------------------------------------------------------------</br>

 
---------------------------------------------------------------------------------------------------------------------


1.java开发经验 完整的项目
1年数据库 sqlserver mysql 存储过程 sql语句 报表
6年java oa系统 医疗app 订单系统  基金销售



2.io 多线程  集合 jvm
io：输入输出流  文件流  
多线程：thread runnable currentThread 线程池 锁
集合：list map dictionary hashmap currenthashmap 自定义集合（链表）
jvm：字节码 编译 内存 垃圾回收 



3.数据结构 算法
数据结构：链表 有序集合  无序集合  类设计（属性和行为）
算法：排序算法：冒泡 快速 交换   斐波拉契数列 数据校验方法 撮合算法 银行家算法



4.数据库 nosql redis codis 
数据库：sqlserver： 存储过程 游标  mysql： bio nio aio  分布式存储 乐观锁 悲观锁  数据库事务 主备份

redis：存储原理（文件目录结构） 调用&监控api  客服端工具 分布式部署   Redis cluster刚出来短期不成熟，生产不建议用。单纯的数据分片，无其他功能。走的是 Apps->redis server jump  redis server，大规模后不方便统一管理

codis：一整套缓存解决方案，包含高可用、数据分片、监控、动态扩态 etc.。走的是 Apps->代理->redis cluster，一定规模后基本都采用这种方式。



5.spring springmvc mybatis springboot springcloud
spring：加载bean原理 配置方式 注解方式 自定义解析 spring类模式（属性&方法） 抽象 继承 缓存   aop
springmvc：配置 监听 拦截器 hadler路由
mybatis：生成工具 xml配置
springboot：注解模式
springcloud：微服务 服务治理 注册 



6.dubbo zookeeper activemq rocketmq tbschedule 中间件
dubbo：分布式服务注册 服务端&客服端配置 工具使用
zookeeper：分布式协调服务 结合dubbo redis等  指标监控 目录树结构存储 四字命令
activemq：分布式消息队列
rocektmq：消息队列，消费端 服务端 监控指标 原理（队列机制） 频道  主题 
tbschedule：任务调度 工具使用 配置
中间件：原理 配置 使用范围



7.tomcat jetty nginx 
tomcat：服务引擎 配置项 监控api
jetty：服务引擎 
nginx：反向代理 生命周期 lua



8.设计模式
设计模式：抽象工厂 观察者模式 单例模式



9.分布式 缓存 并发 消息 负载均衡
分布式：多服务多应用部署
缓存：reids cache mybatis 缓存应用
并发：防御方法：nginx分流 mq分流 数据库加锁 异步处理 最终一致性
消息：mq 
负载均衡：硬件设备 软件设置 业务场景分析 分库分表



10.开源框架 rpc http
开源框架：
rpc：远程服务协议 
http：网络请求拦截 消息头  消息体



11.svn git uml maven idea myeclipse axure jeskins netcat nexus npp openresty postman RedisDesktopManager rocketmq-console ZooInspector confluence

svn：文件管理
git：代码管理 pull push 
uml：时序图 流程图
maven：pom文件 
idea：多项目
myeclipse：开发工具
axure:产品设计工具
jeskins：持续集成工具
netcat:
nexus:jar管理工具
npp：Windows下模拟linux命令
openrestry：nginx代理工具
postman：接口调试工具
RedisDesktopManager：redis客服端工具
rocketmq-console：rocketmq页面工具
ZooInspector：zookeeper客服端工具
confluence：文档工具



12.大数据 elk hadoop hive docker
大数据：数据存储 爬虫 python
elk：部署 日志分析
hadoop：liunx下部署，api存储
hive：基于hadoop存储的数据库
docker：镜像



13.liunx shell、python、lua
liunx：环境搭建 jdk mysql    
shell：命令
python：脚本开发
lua：语法，嵌入式脚本



14.模版 velocity  pdf html oss ftp apidoc
模版：velocity freemarker  groovy
velocity:使用方式
pdf：html 图片转换
html：动态网页
oss：云存储
ftp：服务器存储
apidoc:接口文档生成



15.soa osgi
soa：分布式服务中心
osgi：


16.沟通 表达 博客
沟通：
表达：
博客：



 
---------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------


thread runnable callable start future

volatile
ps -ef| grep java
kill -3 pid

wait notify notifyall
sleep wait

threadlocal
频繁创建和销毁线程
https://www.cnblogs.com/200911/category/901837.html
synchronized lock

concurrenthashmap

feturetask

代码执行很快 这样频繁加锁时间消耗打 不妨让等待锁的

cas 比较交换


aqs 抽象队列同步器

semaphore 信号量

单例模式
代理1模式
工厂模式
观察者模式

hashmap
concunrrenthashmap
动态代理  jdk  接口  cglib 实现类

b+树

冒泡排序

jvm 堆栈 方法区
gc

eden
synchronized  lock

加载  连接 初始化 使用  卸载


https://www.cnblogs.com/200911/category/901837.html

https://www.cnblogs.com/lishun1005/p/6019678.html


redis底层原理
主从架构Master/Slave
哨兵模式
哨兵模式就是不时地监控redis是否按照预期良好地运行（至少是保证主节点是存在的），若一台主机出现问题时，哨兵会自动将该主机下的某一个从机设置为新的主机，并让其他从机和新主机建立主从关系。

AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录


Zookeeper  

Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）

为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。


• Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协
　　   议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者
　　　崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后
　　  ，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。

　　• 为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（
　　　proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识
　　   leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的
　　　统治时期。低32位用于递增计数。
　　• 每个Server在工作过程中有三种状态：
　　　　LOOKING：当前Server不知道leader是谁，正在搜寻
　　　　LEADING：当前Server即为选举出来的leader
　　　　FOLLOWING：leader已经选举出来，当前Server与之同步




https://www.cnblogs.com/raphael5200/p/5285583.html

https://www.cnblogs.com/lanqiu5ge/p/9405601.html


mysql

https://blog.csdn.net/tongdanping/article/details/79878302

myisam 非聚簇索引



redis是nosql(也是个巨大的map) 单线程，但是可处理1秒10w的并发（数据都在内存中）


哨兵模式（后面会讲）怎么互相监督的，就是因为每隔2秒哨兵节点会发布对某节点的判断和自身的信息到某频道，每个哨兵订阅该频道获取其他哨兵节点和主从节点的信息，以达到哨兵间互相监控和对主从节点的监控）和很多专业的消息队列系统（例如Kafka、RocketMQ）相比，Redis的发布订阅略显粗糙，例如无法实现消息堆积和回溯。但胜在足够简单



https://www.cnblogs.com/liouwei4083/p/6073120.html

https://www.cnblogs.com/mengchunchen/p/10059436.html

https://blog.csdn.net/u010682330/article/details/81043419

https://flychao88.iteye.com/blog/1977653



RabbitMQ

https://www.cnblogs.com/jun-ma/p/4840869.html

https://www.cnblogs.com/vipstone/p/9275256.html


dubbo

https://www.cnblogs.com/sunny3096/p/7479648.html

https://www.cnblogs.com/barrywxx/p/8528849.html

https://www.cnblogs.com/aspirant/p/9002631.html



nio bio aio的区别

https://www.cnblogs.com/ygj0930/p/6543960.html


https://www.cnblogs.com/xiaoxi/p/6164383.html
netty




docker



jvm

https://blog.csdn.net/liaomin416100569/article/details/79974742

https://blog.csdn.net/csdnliuxin123524/article/details/81303711

http://www.wannengye.com/pages/Mwh1g9FU/?from=timeline&isappinstalled=0

https://www.cnblogs.com/moonandstar08/p/5628463.html



JVM内存模型
https://www.cnblogs.com/dingyingsi/p/3760447.html

程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。


在Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大

于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展

（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的

虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。



本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其

区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则

是为虚拟机使用到的Native 方法服务。



Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的

唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存



Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（Garbage

Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在

收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；

再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配

的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local

Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，

存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配

内存



根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要

逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小

的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx

和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出

OutOfMemoryError 异常。

方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存

储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽

然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-

Heap（非堆），目的应该是与Java 堆区分开来。



运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有

类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool

Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放

到方法区的运行时常量池中。



Java 堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java 堆内
存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap

space”。

要解决这个区域的异常，一般的手段是首先通过内存映像分析工具（如Eclipse

Memory Analyzer）对dump 出来的堆转储快照进行分析，重点是确认内存中的对象是

否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢

出（Memory Overflow）。图2-5 显示了使用Eclipse Memory Analyzer 打开的堆转储快

照文件。

如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就

能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收

它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确

地定位出泄漏代码的位置。

如果不存在泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查

虚拟机的堆参数（-Xmx 与-Xms），与机器物理内存对比看是否还可以调大，从代码上

检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期

的内存消耗。




-Xms(最小值)和-Xmx(最大值)


https://blog.csdn.net/u011972171/article/details/80398771

https://www.cnblogs.com/damon9094/p/8881185.html

https://www.cnblogs.com/xiaoying1245970347/p/5528419.html


线程共享区：

方法区（Method Area）：方法区是各个线程共享的区域，存放类信息，常量，静态常量，编译器编译后的代码等信息。

Java堆（Heap）：Java堆也是线程共享区域，类的实例存放在这里，一个系统会产生很多Java实例，因此Java堆的空间是最大的，如果Java堆的空间不足，就会抛出OutOfMemoryError异常。

线程私有区：

Java栈（VM Stack）：线程私有区域，生命周期与线程相同，一个线程对应一个Java栈，每执行一个方法就会向栈里压一个元素，这个元素叫“栈帧”，栈帧中包含了方法中保存了该方法调用的参数、局部变量和返回地址等信息，如果栈空间不足了就会抛出StackOverflowError异常。

本地方法栈（Native Method Stack）：和Java栈类似，本地方法栈是用来执行本地方法的，存放的方法调用本地方法接口，最终调用本地方法库，实现与操作系统，硬件交互的目的。

程序计数器：这里对应的类以及加载，实例对象，方法，静态变量去了该去的地方，那么问题来了，程序该怎么执行，哪个方法先执行，哪个方法后执行，这些指令执行的顺序就是PC寄存器在管，它的作用就是控制程序指令的执行顺序。




1，加载

加载是类装载的第一步，内存中生成一个代表这个类的java.lang.class对象，通过class文件的路径读取到二进制流，并解析二进制里的元数据（类型，常量等），作为方法区这个类的各种数据量的入口；这里的不一定从class文件获取，这里既可以从ZIP包（jar,war）包中获取，也在运行时动态生成（jsp转换成class文件，动态代理生成）。

2，连接

连接又可分为验证，准备，解析。

2.1，验证

验证主要是判断class文件的合法性，对版本号进行验证（例如如果使用java1.8编译后的class文件要再java1.6虚拟机上运行），还会对元数据，字节编码等进行验证，确保class文件里的字节流信息符合当前虚拟机的要求，不会危害虚拟机的安全。

2.2，准备

准备主要是分配内存，为变量分配初始值，即在方法区中分配这些变量所使用的内存空间，例如：

public static int i = 1；

在准备阶段i的值会被初始化为0，后面的类的初始化阶段才会赋值为1；

public static final int i = 1；

对应常量（static final）i，在准备阶段就会被赋值1；

2.3，解析

解析就是把代码中的符号引用替换为直接引用；例如某个类继承了java.lang.Object，原来的符号引用记录的是“java.lang.Object”，并不是java.lang,Object对象,直接引用就是找出对应的java.lang.Object对应的内存地址，建立直接引用关系；

3，初始化

初始化的过程包括执行类构造器方法，static变量赋值语句，static{}代码块，如果是一个子类进行初始化会先对其父类进行初始化，保证其父类在子类之前进行初始化；所以其实在java中初始化一个类，那么必然是先初始化java.lang.Object，因为所有的java类都继承自java.lang.Object。

以下几种情况不会执行类初始化：

通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
定义对象数组，不会触发该类的初始化。
常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
通过类名获取Class对象，不会触发类的初始化。
通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
通过ClassLoader默认的loadClass方法，也不会触发初始化动作。



https://www.cnblogs.com/ITtangtang/p/3978102.html


https://www.cnblogs.com/huangjuncong/p/9425603.html

https://www.cnblogs.com/huangjuncong/p/8442674.html


https://www.cnblogs.com/cheyunhua/p/8144556.html

















MySQL

https://www.cnblogs.com/bypp/p/7755307.html


https://www.cnblogs.com/wyy123/p/6269875.html
https://www.cnblogs.com/wajika/p/6718668.html

https://www.cnblogs.com/liujiacai/p/7605612.html


https://www.cnblogs.com/mysql-dba/p/5083484.html






mybatis


https://blog.csdn.net/a745233700/article/details/80977133



面试

https://www.cnblogs.com/wang-meng/category/857645.html



Nginx

https://www.cnblogs.com/yueminghai/p/8657861.html

https://www.cnblogs.com/zhichaoma/p/7989655.html


tomcat

https://www.cnblogs.com/jpfss/p/7390211.html



https://www.cnblogs.com/ilinuxer/p/6580998.html


--------------------- 



---------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------</br>
----------------------------------------------------------------------------</br>
----------------------------------------------------------------------------</br>

</body>
</html>
